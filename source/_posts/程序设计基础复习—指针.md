---
title: 程序设计基础复习—指针
date: 2023-06-01 18:27:20
categories: 计算机
description: 应付考试罢了
---
~~明天考试急急急~~  
6.2更新：已寄。
# 地址与指针
`int x = 1;`    
x储存于某个*地址*，地址上储存的值为**1**；
如何得到这个地址？使用算子 `&`；    
`printf("%d",&x);       //输出地址（整型）`  
  
*指针变量*是用来**存放地址**的变量；
  - 定义：`int *p;`
  - `*`的含义：作为*类型说明符*表示p是一个指针；作为*算子*表示指向地址对应的变量；
  - 赋值时注意：与指向变量类型一致；不用于储存具体值；
  - 变更时注意：`*p1 = *p2`与`p1 = p2`的区别，前者修改指向变量的值，后者修改指向的变量/地址；  

# 数组与指针
数组中的各元素：
  - 地址连续，相差`sizeof(typeof(example[]))`个字节；
  - 访问时只需要**首元素**地址即可；  
## 一维数组与指针
```c
int a[3] = {1,2,3};

int *p = a;
int *p = &a[0];     
//以上两句等价

*(p+1) = 100;
a[1] = 100;
p[1] = 100;
//以上三句等价
```
- 数组名本身表示数组的**首元素地址**；  
- 指向数组首元素的指针`p`加上`i`即可指向第`i`位的元素的地址，同时`p[]`与`a[]`也都可表示数组，用下标的形式访问； 
- 字符串数组同理；
## 二维数组与指针
```c
int b[2][2] = {1,2,3,4};    //b[i][j],i表示行数，j表示列数
int (*p)[2] = b;
//定义方式为：类型说明符 (*指针变量名)[长度]

a[1][0] = 100;
*(*(p+1)+0) = 100;
p[1][0] = 100;
//以上三句等价
```
- 定义中的*长度*指指向数组的**列数**且不可省略！
- `*(p+1)`表示第0+1行这个*一维数组*的地址，从而`*(p+1)+1`表示第0+1行第0+1列元素的地址;  

# "const"与指针
```c
int a = 1;

const int *p1 = &a;
int* const p2 = &a;
const int* const p3 = &a;
```
如何辨析`p1,p2,p3`？***从右向左读***；
1. 若先遇到`const`表示该变量`p`的内容不可修改(指向的地址)；
2. 再遇到`*`表示该变量是一个指针；`int`表示这个指针指向整型变量；
3. 若再遇到`const`表示整型指针所指的整型变量不会因为`p`的改变而改变；
```c
int b = 2;

*p1 = &b;       //p1的指向被修改到指向b
*p2 = 2;        //p2所指向的变量a被赋值为2
//以上两句均合法，若对调则不合法
```
# 函数调用与指针
- 参数传递的两种方式：
  - 传值：形参储存实参的值，形参变化而不影响实参；
  - **传指针**：形参储存实参的地址，实参**可以**变化；
- 为函数传入数组参数实际上就是传入了***数组的指针***！好处在于节省空间；
  ```c
  void function(int a[]){}
  void function(int *a){}
  //以上两种定义效果一致
  ```
- 二维数组作为形参时***必须说明列数（长度）***
  ```c
  void function(int a[3][3]){}

  void function(int a[][3]){}
  void function(int (*a)[3]){}
  //以上两种正确且等价
  ```
- 在函数不需要修改传入值时，使用`const`！如`void function(const int *a)`