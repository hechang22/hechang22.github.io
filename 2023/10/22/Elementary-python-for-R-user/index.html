<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>给R用户的基础Python教程 | A tiny home</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="https://unpkg.com/normalize.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/pure-min.css"><link rel="stylesheet" type="text/css" href="https://unpkg.com/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="https://unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="https://unpkg.com/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="https://unpkg.com/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="https://unpkg.com/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="https://unpkg.com/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">给R用户的基础Python教程</h1><a id="logo" href="/.">A tiny home</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">给R用户的基础Python教程</h1><div class="post-meta">2023-10-22<span> | </span><span class="category"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></span></div><div class="post-content"><p><a target="_blank" rel="noopener" href="https://cran.r-project.org/web/packages/reticulate/vignettes/python_primer.html">原文</a>，是R::reticulate提供的小教程。</p>
<h2 id="R用户指南：Python入门"><a href="#R用户指南：Python入门" class="headerlink" title="R用户指南：Python入门"></a>R用户指南：Python入门</h2><p>你可能会发现自己想阅读和理解一些Python代码，甚至将一些Python代码移植到R中。这份指南旨在帮助你尽快完成这些任务。正如你将看到的，R和Python足够相似，以至于可以在不学习全部Python的情况下做到这一点。我们从容器类型的基础知识开始，逐步介绍到类、特殊方法、迭代器协议、上下文协议等！</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>在Python中，空格很重要。在R中，表达式是通过<code>&#123;&#125;</code>组合成代码块的。在Python中，这是通过使表达式共享一个缩进级别来完成的。例如，一个带有R代码块的表达式可能是：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  cat<span class="punctuation">(</span><span class="string">&quot;This is one expression. \n&quot;</span><span class="punctuation">)</span></span><br><span class="line">  cat<span class="punctuation">(</span><span class="string">&quot;This is another expression. \n&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">#&gt; This is one expression.</span></span><br><span class="line"><span class="comment">#&gt; This is another expression.</span></span><br></pre></td></tr></table></figure>

<p>在Python中的等效代码是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;This is one expression.&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;This is another expression.&quot;</span>)</span><br><span class="line"><span class="comment">#&gt; This is one expression.</span></span><br><span class="line"><span class="comment">#&gt; This is another expression.</span></span><br></pre></td></tr></table></figure>

<p>Python接受制表符或空格作为缩进空格，但当它们混合使用时，规则会变得复杂。大多数风格指南建议（并且IDE默认使用）仅使用空格。</p>
<h3 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h3><p>在R中，<code>list()</code>是一个可以用来组织R对象的容器。R的<code>list()</code>功能丰富，没有单一的直接等价物在Python中支持所有相同的功能。相反，有（至少）4种不同的Python容器类型需要你注意：列表、字典、元组和集合。</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>Python列表通常使用裸括号<code>[]</code>创建。Python内置的<code>list()</code>函数更像是一个强制函数，更接近于R的<code>as.list()</code>。关于Python列表最重要的是它们是就地修改的。注意下面的例子中，<code>y</code>反映了对<code>x</code>所做的更改，因为两个符号指向的底层列表对象就地被修改了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = x    <span class="comment"># `y`和`x`现在引用同一个列表！</span></span><br><span class="line">x.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x is&quot;</span>, x)</span><br><span class="line"><span class="comment">#&gt; x is [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y is&quot;</span>, y)</span><br><span class="line"><span class="comment">#&gt; y is [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p>一个可能让R用户担忧的Python习惯是通过对<code>append()</code>方法来扩展列表。在R中扩展列表通常是缓慢的，最好避免。但由于Python的列表是就地修改的（并且在追加项目时避免了完整列表的复制），因此就地扩展Python列表是高效的。</p>
<p>你可能会遇到的围绕Python列表的一些语法糖是使用<code>+</code>和<code>*</code>与列表。这些是连接和复制操作符，类似于R的<code>c()</code>和<code>rep()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>]</span><br><span class="line">x</span><br><span class="line"><span class="comment">#&gt; [1]</span></span><br><span class="line">x + x</span><br><span class="line"><span class="comment">#&gt; [1, 1]</span></span><br><span class="line">x * <span class="number">3</span></span><br><span class="line"><span class="comment">#&gt; [1, 1, 1]</span></span><br></pre></td></tr></table></figure>

<p>你可以使用尾随<code>[]</code>的整数来索引列表，但请注意索引是基于0的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line">x[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line">x[<span class="number">2</span>]</span><br><span class="line"><span class="comment">#&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  x[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">  <span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment">#&gt; list index out of range</span></span><br></pre></td></tr></table></figure>

<p>在索引时，负数从容器的末尾开始计数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">x[-<span class="number">1</span>]</span><br><span class="line"><span class="comment">#&gt; 3</span></span><br><span class="line">x[-<span class="number">2</span>]</span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line">x[-<span class="number">3</span>]</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>你可以使用<code>:</code>在括号中切片列表。请注意切片语法不包括切片范围的末尾。你还可以可选地指定步长。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">x[<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 获取索引位置0,1的项</span></span><br><span class="line"><span class="comment">#&gt; [1, 2]</span></span><br><span class="line">x[<span class="number">1</span>:]  <span class="comment"># 从索引位置1开始获取所有项</span></span><br><span class="line"><span class="comment">#&gt; [2, 3, 4, 5, 6]</span></span><br><span class="line">x[:-<span class="number">2</span>] <span class="comment"># 从开始获取直到倒数第二个项</span></span><br><span class="line"><span class="comment">#&gt; [1, 2, 3, 4]</span></span><br><span class="line">x[:]   <span class="comment"># 获取所有项（用于复制列表，以便不就地修改的习语）</span></span><br><span class="line"><span class="comment">#&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class="line">x[::<span class="number">2</span>] <span class="comment"># 获取所有项，步长为2</span></span><br><span class="line"><span class="comment">#&gt; [1, 3, 5]</span></span><br><span class="line">x[<span class="number">1</span>::<span class="number">2</span>] <span class="comment"># 从索引1开始获取所有项，步长为2</span></span><br><span class="line"><span class="comment">#&gt; [2, 4, 6]</span></span><br></pre></td></tr></table></figure>

<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组的行为类似于列表，除了它们是不可变的，并且没有像<code>append()</code>这样的就地修改方法。它们通常使用裸<code>()</code>构建，但括号不是严格要求的，你可能会看到一个隐式的元组仅由逗号分隔的表达式定义。因为括号也可以用来指定像<code>(x + 3) * 4</code>这样的表达式的运算顺序，所以需要特殊的语法来定义长度为1的元组：尾随逗号。元组最常见的是在函数中遇到，这些函数接受可变数量的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>) <span class="comment"># 长度为2的元组</span></span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">len</span>(x)</span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">#&gt; (1, 2)</span></span><br><span class="line"></span><br><span class="line">x = (<span class="number">1</span>,) <span class="comment"># 长度为1的元组</span></span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">len</span>(x)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">#&gt; (1,)</span></span><br><span class="line"></span><br><span class="line">x = () <span class="comment"># 长度为0的元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>(x) = &#125;</span>; <span class="subst">&#123;<span class="built_in">len</span>(x) = &#125;</span>; <span class="subst">&#123;x = &#125;</span>&quot;</span>)</span><br><span class="line"><span class="comment">#&gt; type(x) = &lt;class &#x27;tuple&#x27;&gt;; len(x) = 0; x = ()</span></span><br><span class="line"><span class="comment"># 示例插值字符串字面量</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>, <span class="number">2</span> <span class="comment"># 也是一个元组</span></span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">len</span>(x)</span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span>, <span class="comment"># 小心一个尾随逗号！这是一个元组！</span></span><br><span class="line"><span class="built_in">type</span>(x)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">len</span>(x)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br></pre></td></tr></table></figure>

<h5 id="打包和解包"><a href="#打包和解包" class="headerlink" title="打包和解包"></a>打包和解包</h5><p>元组是驱动Python中《打包》和《解包》语义的容器。Python提供了方便，允许你在单个表达式中分配多个符号。这称为《解包》。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a, b, c = x</span><br><span class="line">a</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line">b</span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line">c</span><br><span class="line"><span class="comment">#&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>（你可以使用<code>zeallot::`%&lt;-%</code>从R访问类似的解包行为）。</p>
<p>元组解包可以在多种上下文中发生，例如迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xx = ((<span class="string">&quot;a&quot;</span>, <span class="number">1</span>),</span><br><span class="line">      (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>))</span><br><span class="line"><span class="keyword">for</span> x1, x2 <span class="keyword">in</span> xx:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;x1 = &quot;</span>, x1)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;x2 = &quot;</span>, x2)</span><br><span class="line"><span class="comment">#&gt; x1 =  a</span></span><br><span class="line"><span class="comment">#&gt; x2 =  1</span></span><br><span class="line"><span class="comment">#&gt; x1 =  b</span></span><br><span class="line"><span class="comment">#&gt; x2 = 2</span></span><br></pre></td></tr></table></figure>

<p>如果你尝试将容器解包到错误数量的符号，Python会抛出错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a, b, c = x <span class="comment"># 成功</span></span><br><span class="line">a, b = x    <span class="comment"># 错误，x有太多值要解包</span></span><br><span class="line"><span class="comment">#&gt; ValueError: too many values to unpack (expected 2)</span></span><br><span class="line">a, b, c, d = x <span class="comment"># 错误，x没有足够的值要解包</span></span><br><span class="line"><span class="comment">#&gt; ValueError: not enough values to unpack (expected 4, got 3)</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>*</code>作为前缀来解包可变数量的参数。（当我们讨论函数时，你将再次看到<code>*</code>前缀）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">a, *the_rest = x</span><br><span class="line">a</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line">the_rest</span><br><span class="line"><span class="comment">#&gt; [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>你也可以解包嵌套结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = ((<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">(a, b), (c, d) = x</span><br></pre></td></tr></table></figure>

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典与R环境最为相似。它们是一个容器，你可以通过名称来检索项目，尽管在Python中名称（在Python的术语中称为_key_）不需要像在R中那样是字符串。它可以是任何具有<code>hash()</code>方法的Python对象（这意味着，它可以是几乎所有的Python对象）。它们可以使用<code>&#123;key: value&#125;</code>这样的语法创建。像Python列表一样，它们是就地修改的。请注意，<code>r_to_py()</code>将R命名列表转换为字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;key1&quot;</span>: <span class="number">1</span>,</span><br><span class="line">     <span class="string">&quot;key2&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">d2 = d</span><br><span class="line">d</span><br><span class="line"><span class="comment">#&gt; &#123;&#x27;key1&#x27;: 1, &#x27;key2&#x27;: 2&#125;</span></span><br><span class="line">d[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line">d[<span class="string">&quot;key3&quot;</span>] = <span class="number">3</span></span><br><span class="line">d2 <span class="comment"># 就地修改！</span></span><br><span class="line"><span class="comment">#&gt; &#123;&#x27;key1&#x27;: 1, &#x27;key2&#x27;: 2, &#x27;key3&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>像R环境（与R的命名列表不同），你不能使用整数来索引字典以获取特定索引位置的项目。字典是_无序_容器。<br>（然而—从Python 3.7开始，字典确实保留了项目插入顺序）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;key1&quot;</span>: <span class="number">1</span>, <span class="string">&quot;key2&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">d[<span class="number">1</span>] <span class="comment"># 错误</span></span><br><span class="line"><span class="comment">#&gt; KeyError: 1</span></span><br></pre></td></tr></table></figure>

<p>与R的命名列表语义最接近的容器是<code>OrderedDict</code>，<br>但在Python代码中相对不常见，因此我们不再进一步介绍。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合是一个容器，可以用来高效地跟踪唯一项目或去除列表中的重复项。它们使用<code>&#123;val1, val2&#125;</code>（像字典，但没有<code>:</code>）构建。将它们视为只使用键的字典。集合有许多用于成员操作的高效方法，如<code>intersection()</code>, <code>issubset()</code>, <code>union()</code>等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">type</span>(s)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;set&#x27;&gt;</span></span><br><span class="line">s</span><br><span class="line"><span class="comment">#&gt; &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line">s.add(<span class="number">1</span>)</span><br><span class="line">s</span><br><span class="line"><span class="comment">#&gt; &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用for进行迭代"><a href="#使用for进行迭代" class="headerlink" title="使用for进行迭代"></a>使用<code>for</code>进行迭代</h3><p>Python中的<code>for</code>语句可以用来迭代任何类型的容器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line"><span class="comment">#&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>R有一个相对有限的对象集合可以传递给<code>for</code>。相比之下，Python提供了一个迭代器协议接口，这意味着作者可以定义具有自定义行为的对象，这些对象被<code>for</code>调用。（我们将在讨论类时提供一个如何定义自定义可迭代对象的例子）。你可能想从R使用reticulate来使用Python可迭代对象，因此有助于稍微剥离语法糖，展示Python中<code>for</code>语句正在做什么，以及如何手动逐步进行。</p>
<p>发生两件事：首先，从提供的对象构建一个迭代器。然后，新迭代器对象被反复调用<code>next()</code>直到耗尽。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(l) <span class="comment"># 创建一个迭代器对象</span></span><br><span class="line">it</span><br><span class="line"><span class="comment">#&gt; &lt;list_iterator object at 0x1402267a0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用迭代器的 `next` 直到耗尽：</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; 3</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; StopIteration</span></span><br></pre></td></tr></table></figure>

<p>在R中，你可以使用reticulate以相同的方式遍历迭代器。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>reticulate<span class="punctuation">)</span></span><br><span class="line">l <span class="operator">&lt;-</span> r_to_py<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">it <span class="operator">&lt;-</span> as_iterator<span class="punctuation">(</span>l<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">iter_next<span class="punctuation">(</span>it<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; 1.0</span></span><br><span class="line">iter_next<span class="punctuation">(</span>it<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; 2.0</span></span><br><span class="line">iter_next<span class="punctuation">(</span>it<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; 3.0</span></span><br><span class="line">iter_next<span class="punctuation">(</span>it<span class="punctuation">,</span> completed <span class="operator">=</span> <span class="string">&quot;StopIteration&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; [1] &quot;StopIteration&quot;</span></span><br></pre></td></tr></table></figure>

<p>迭代字典首先需要了解你是在迭代键、值还是两者。字典有方法允许你指定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;key1&quot;</span>: <span class="number">1</span>, <span class="string">&quot;key2&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">  <span class="built_in">print</span>(key)</span><br><span class="line"><span class="comment">#&gt; key1</span></span><br><span class="line"><span class="comment">#&gt; key2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">  <span class="built_in">print</span>(value)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">  <span class="built_in">print</span>(key, <span class="string">&quot;:&quot;</span>, value)</span><br><span class="line"><span class="comment">#&gt; key1 : 1</span></span><br><span class="line"><span class="comment">#&gt; key2 : 2</span></span><br></pre></td></tr></table></figure>

<h4 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h4><p>推导式是特殊语法，允许你构建一个像列表或字典这样的容器，同时对每个元素执行一个小操作或单个表达式。你可以将其视为R的<code>lapply</code>的特殊语法。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从x构建一个列表推导式，其中你为每个元素添加100</span></span><br><span class="line">l = [element + <span class="number">100</span> <span class="keyword">for</span> element <span class="keyword">in</span> x]</span><br><span class="line">l</span><br><span class="line"><span class="comment">#&gt; [101, 102, 103]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从x构建一个字典推导式，其中键是一个字符串。</span></span><br><span class="line"><span class="comment"># Python的str()类似于R的as.character()</span></span><br><span class="line">d = &#123;<span class="built_in">str</span>(element) : element + <span class="number">100</span></span><br><span class="line">     <span class="keyword">for</span> element <span class="keyword">in</span> x&#125;</span><br><span class="line">d</span><br><span class="line"><span class="comment">#&gt; &#123;&#x27;1&#x27;: 101, &#x27;2&#x27;: 102, &#x27;3&#x27;: 103&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用def定义函数"><a href="#使用def定义函数" class="headerlink" title="使用def定义函数"></a>使用<code>def</code>定义函数</h3><p>Python函数使用<code>def</code>语句定义。指定函数参数和默认值的语法与R非常相似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">name = <span class="string">&quot;World&quot;</span></span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, name)</span><br><span class="line"></span><br><span class="line">my_function()</span><br><span class="line"><span class="comment">#&gt; Hello World</span></span><br><span class="line">my_function(<span class="string">&quot;Friend&quot;</span>)</span><br><span class="line"><span class="comment">#&gt; Hello Friend</span></span><br></pre></td></tr></table></figure>

<p>等效的R代码片段将是</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_function <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>name <span class="operator">=</span> <span class="string">&quot;World&quot;</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">  cat<span class="punctuation">(</span><span class="string">&quot;Hello&quot;</span><span class="punctuation">,</span> name<span class="punctuation">,</span> <span class="string">&quot;\n&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">my_function<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Hello World</span></span><br><span class="line">my_function<span class="punctuation">(</span><span class="string">&quot;Friend&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#&gt; Hello Friend</span></span><br></pre></td></tr></table></figure>

<p>与R函数不同，函数中的最后一个值不会自动返回。Python需要一个明确的返回语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">  <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(fn())</span><br><span class="line"><span class="comment">#&gt; None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>():</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(fn())</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>（对于高级R用户的注释：Python没有与R的参数“承诺”等效的东西。函数参数默认值在函数构造时评估一次。如果你定义了一个Python函数，并且默认参数值为可变对象，如Python列表，这可能会让你感到惊讶！）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">x = []</span>):</span><br><span class="line">  x.append(<span class="string">&quot;was called&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">my_func()</span><br><span class="line"><span class="comment">#&gt; [&#x27;was called&#x27;]</span></span><br><span class="line">my_func()</span><br><span class="line"><span class="comment">#&gt; [&#x27;was called&#x27;, &#x27;was called&#x27;]</span></span><br><span class="line">my_func()</span><br><span class="line"><span class="comment">#&gt; [&#x27;was called&#x27;, &#x27;was called&#x27;, &#x27;was called&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>你还可以使用与R中的<code>...</code>类似的语法来定义接受可变数量参数的Python函数。一个值得注意的区别是R的<code>...</code>对命名和未命名参数没有区分，但Python确实有区分。在Python中，在单个<code>*</code>前缀捕获未命名参数，两个<code>**</code>表示捕获关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;args = &quot;</span>, args) <span class="comment"># args是一个元组</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;kwargs = &quot;</span>, kwargs) <span class="comment"># kwargs是一个字典</span></span><br><span class="line"></span><br><span class="line">my_func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a = <span class="number">4</span>, b = <span class="number">5</span>, c = <span class="number">6</span>)</span><br><span class="line"><span class="comment">#&gt; args =  (1, 2, 3)</span></span><br><span class="line"><span class="comment">#&gt; kwargs =  &#123;&#x27;a&#x27;: 4, &#x27;b&#x27;: 5, &#x27;c&#x27;: 6&#125;</span></span><br></pre></td></tr></table></figure>

<p>在函数定义签名中的<code>*</code>和<code>**</code>将参数打包，在函数调用中它们解包参数。在函数调用中解包参数等同于在R中使用<code>do.call()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">  <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">args = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">my_func(*args)</span><br><span class="line"><span class="comment">#&gt; 1 2 3</span></span><br><span class="line"></span><br><span class="line">kwargs = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">my_func(**kwargs)</span><br><span class="line"><span class="comment">#&gt; 1 2 3</span></span><br></pre></td></tr></table></figure>

<h3 id="使用class定义类"><a href="#使用class定义类" class="headerlink" title="使用class定义类"></a>使用<code>class</code>定义类</h3><p>可以说，在R中，代码组合的首要单位是<code>function</code>，而在Python中，它是<code>class</code>。你可以是一个非常有生产力的R用户，而从未使用过R6、引用类或类似的R等价物，这些等价物是Python<code>class</code>的对象导向风格的。</p>
<p>在Python中，理解<code>class</code>对象的基础知识是必要的，因为<code>class</code>是你在Python中组织和查找方法的方式。<br>（与R的方法不同，R的方法是通过从通用方法派发的）。幸运的是，<code>class</code>的基础知识是容易理解的。</p>
<p>如果你第一次接触面向对象编程，不要被吓倒。我们将首先构建一个简单的Python类进行演示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  <span class="keyword">pass</span> <span class="comment"># `pass`意味着什么也不做。</span></span><br><span class="line"></span><br><span class="line">MyClass</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;__main__.MyClass&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(MyClass)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;type&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p>实例化类后，你可以与之交互，你会看到它已经带有很多属性（Python中的<code>dir()</code>等同于R中的<code>names()</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>(MyClass)</span><br><span class="line"><span class="comment">#&gt; [&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getstate__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="为什么会有这么多下划线？"><a href="#为什么会有这么多下划线？" class="headerlink" title="为什么会有这么多下划线？"></a>为什么会有这么多下划线？</h4><p>Python通常通过将名称包裹在双下划线中来表示某些东西是特殊的。一个被双下划线包裹的特殊标记通常被称为“dunder”。“特殊”不是一个技术术语，它只是意味着该标记调用了Python语言功能。一些dunder标记只是代码作者可以插入特定语法糖的方式，其他是由解释器提供，否则很难获得的值，还有的是用于扩展语言接口的（例如，迭代器协议），最后，一小部分dunders是真正难以理解的。幸运的是，作为R用户，你只需要了解一些容易理解的dunders。</p>
<p>当你阅读Python代码时，最常遇到的dunder方法是<code>__init__()</code>。这是一个在类构造函数被调用时调用的函数，也就是说，当一个类被<strong>实例化</strong>时。它的目的是初始化新类实例。（在非常复杂的代码库中，你可能还会遇到定义了<code>__new__</code>的类，这在<code>__init__</code>之前被调用）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;MyClass&#x27;s definition body is being evaluated&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="variable language_">self</span>, <span class="string">&quot;is initializing&quot;</span>)</span><br><span class="line"><span class="comment">#&gt; MyClass&#x27;s definition body is being evaluated</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;MyClass is finished being created&quot;</span>)</span><br><span class="line"><span class="comment">#&gt; MyClass is finished being created</span></span><br><span class="line"></span><br><span class="line">instance = MyClass()</span><br><span class="line"><span class="comment">#&gt; &lt;__main__.MyClass object at 0x140266330&gt; is initializing</span></span><br><span class="line"><span class="built_in">print</span>(instance)</span><br><span class="line"><span class="comment">#&gt; &lt;__main__.MyClass object at 0x140266330&gt;</span></span><br><span class="line"></span><br><span class="line">instance2 = MyClass()</span><br><span class="line"><span class="comment">#&gt; &lt;__main__.MyClass object at 0x11e3ad490&gt; is initializing</span></span><br><span class="line"><span class="built_in">print</span>(instance2)</span><br><span class="line"><span class="comment">#&gt; &lt;__main__.MyClass object at 0x11e3ad490&gt;</span></span><br></pre></td></tr></table></figure>

<p>请注意几点：</p>
<ul>
<li><p><code>class</code>语句接受一个代码块，该代码块定义的公共缩进级别。代码块具有与其他任何接受代码块的表达式（如<code>if</code>和<code>def</code>）完全相同的语义。类的主体只在<strong>第一次</strong>被评估，即在类构造函数第一次被创建时。注意，这里定义的任何对象都由类的所有实例共享！</p>
</li>
<li><p><code>__init__</code>只是一个普通函数，像任何其他函数一样用<code>def</code>定义。除了它在类体内部定义。</p>
</li>
<li><p><code>__init__</code>接受一个参数：<code>self</code>。<br><code>self</code>是正在初始化的类实例（注意<code>self</code>和<code>instance</code>之间的相同内存地址）。还要注意，我们调用<code>MyClass()</code>创建类实例时没有提供<code>self</code>，<code>self</code>被解释器插入到函数调用中。</p>
</li>
<li><p>每次创建新实例时都会调用<code>__init__</code>。</p>
</li>
</ul>
<p>在<code>class</code>代码块中定义的函数称为方法，重要的是要知道每次从类实例调用方法时，实例都会被插入到函数调用中作为第一个参数。这适用于类中定义的所有函数，包括dunders。（唯一的例外是如果函数被装饰有类似<code>@classmethod</code>或<code>@staticmethod</code>的装饰器）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">a_method</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;MyClass.a_method() was called with&quot;</span>, <span class="variable language_">self</span>)</span><br><span class="line"></span><br><span class="line">instance = MyClass()</span><br><span class="line">instance.a_method()</span><br><span class="line"><span class="comment">#&gt; MyClass.a_method() was called with &lt;__main__.MyClass object at 0x11e3c7f20&gt;</span></span><br><span class="line"></span><br><span class="line">MyClass.a_method()     <span class="comment"># 错误，缺少必需的参数`self`</span></span><br><span class="line"><span class="comment">#&gt; TypeError: MyClass.a_method() missing 1 required positional argument: &#x27;self&#x27;</span></span><br><span class="line">MyClass.a_method(instance) <span class="comment"># 与instance.a_method()相同</span></span><br><span class="line"><span class="comment">#&gt; MyClass.a_method() was called with &lt;__main__.MyClass object at 0x11e3c7f20&gt;</span></span><br></pre></td></tr></table></figure>

<p>其他一些值得了解的dunder包括：</p>
<ul>
<li><p><code>__getitem__</code>：当使用<code>[</code>进行子集操作时调用的函数（等同于在R中定义<code>[</code> S3方法）。</p>
</li>
<li><p><code>__getattr__</code>：当使用<code>.</code>进行子集操作时调用的函数（等同于在R中定义<code>$</code> S3方法）。</p>
</li>
<li><p><code>__iter__</code>和<code>__next__</code>：由<code>for</code>调用的函数。</p>
</li>
<li><p><code>__call__</code>：当类实例像函数一样被调用时调用（例如，<code>instance()</code>）。</p>
</li>
<li><p><code>__bool__</code>：由<code>if</code>和<code>while</code>调用（等同于R中的<code>as.logical()</code>，但只返回标量，而不是向量）。</p>
</li>
<li><p><code>__repr__</code>, <code>__str__</code>, 用于格式化和漂亮的打印函数（类似于R中的<code>format()</code>, <code>dput()</code>, 和<code>print()</code>方法）。</p>
</li>
<li><p><code>__enter__</code>和<code>__exit__</code>：由<code>with</code>调用的函数。</p>
</li>
<li><p>许多内置的Python函数只是调用dunder的糖，例如：调用<code>repr(x)</code>与<code>x.__repr__()</code>相同。<br>其他内置函数只是调用dunder的糖，包括<code>next()</code>, <code>iter()</code>, <code>str()</code>, <code>list()</code>, <code>dict()</code>, <code>bool()</code>, <code>dir()</code>, <code>hash()</code>等等！</p>
</li>
</ul>
<h4 id="迭代器，再次访问"><a href="#迭代器，再次访问" class="headerlink" title="迭代器，再次访问"></a>迭代器，再次访问</h4><p>现在我们已经掌握了<code>class</code>的基础知识，是时候重新访问迭代器了。首先，一些术语：</p>
<p><strong>可迭代</strong>：可以被迭代的东西。<br>具体来说，是一个定义了<code>__iter__</code>方法的类，其工作是返回一个<strong>迭代器</strong>。</p>
<p><strong>迭代器</strong>：迭代的东西。<br>具体来说，是一个定义了<code>__next__</code>方法的类，其工作是每次被调用时返回下一个元素，然后在耗尽时抛出一个<code>StopIteration</code>异常。</p>
<p>常见的是看到既是可迭代又是迭代器的类，其中<code>__iter__</code>方法只是一个返回<code>self</code>的存根。</p>
<p>这是一个Python<code>range</code>的自定义可迭代&#x2F;迭代器实现（类似于R中的<code>seq</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRange</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, start, end</span>):</span><br><span class="line">    <span class="variable language_">self</span>.start = start</span><br><span class="line">    <span class="variable language_">self</span>.end = end</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 重置我们的计数器。</span></span><br><span class="line">    <span class="variable language_">self</span>._index = <span class="variable language_">self</span>.start - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>._index &lt; <span class="variable language_">self</span>.end:</span><br><span class="line">      <span class="variable language_">self</span>._index += <span class="number">1</span> <span class="comment"># 增加</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">self</span>._index</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> MyRange(<span class="number">1</span>, <span class="number">3</span>):</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line"><span class="comment">#&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动做`for`做的事情</span></span><br><span class="line">r = MyRange(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">it = <span class="built_in">iter</span>(r)</span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; 3</span></span><br><span class="line"><span class="built_in">next</span>(it)</span><br><span class="line"><span class="comment">#&gt; StopIteration</span></span><br></pre></td></tr></table></figure>

<h3 id="使用yield定义生成器"><a href="#使用yield定义生成器" class="headerlink" title="使用yield定义生成器"></a>使用<code>yield</code>定义生成器</h3><p>生成器是包含一个或多个<code>yield</code>语句的特殊Python函数。一旦在传递给<code>def</code>的代码块中包含<code>yield</code>，语义就发生了显著变化。你不再仅仅定义一个函数，而是一个生成器构造函数！反过来，调用生成器构造函数会创建一个生成器对象，这只是另一种类型的迭代器。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_generator_constructor</span>():</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 乍一看，它看起来像一个常规函数</span></span><br><span class="line">my_generator_constructor</span><br><span class="line"><span class="comment">#&gt; &lt;function my_generator_constructor at 0x1402579c0&gt;</span></span><br><span class="line"><span class="built_in">type</span>(my_generator_constructor)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;function&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是调用它返回一些特别的东西，一个&#x27;generator object&#x27;&gt;</span></span><br><span class="line">my_generator = my_generator_constructor()</span><br><span class="line">my_generator</span><br><span class="line"><span class="comment">#&gt; &lt;generator object my_generator_constructor at 0x11e3ff530&gt;</span></span><br><span class="line"><span class="built_in">type</span>(my_generator)</span><br><span class="line"><span class="comment">#&gt; &lt;class &#x27;generator&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器对象既是可迭代的也是迭代器</span></span><br><span class="line"><span class="comment"># 它的`__iter__`方法是只是一个返回`self`的存根</span></span><br><span class="line"><span class="built_in">iter</span>(my_generator) == my_generator == my_generator.__iter__()</span><br><span class="line"><span class="comment">#&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 像任何其他迭代器一样逐步进行</span></span><br><span class="line"><span class="built_in">next</span>(my_generator)</span><br><span class="line"><span class="comment">#&gt; 1</span></span><br><span class="line">my_generator.__next__() <span class="comment"># next()只是调用dunder的糖</span></span><br><span class="line"><span class="comment">#&gt; 2</span></span><br><span class="line"><span class="built_in">next</span>(my_generator)</span><br><span class="line"><span class="comment">#&gt; 3</span></span><br><span class="line"><span class="built_in">next</span>(my_generator)</span><br><span class="line"><span class="comment">#&gt; StopIteration</span></span><br></pre></td></tr></table></figure>

<p>遇到<code>yield</code>就像按下函数执行的暂停按钮，它保留了函数体中所有内容的状态，并将控制权返回给迭代生成器对象的任何东西。调用生成器对象上的<code>next()</code>会恢复函数体的执行，直到遇到下一个<code>yield</code>，或者函数结束。</p>
<h3 id="import和模块"><a href="#import和模块" class="headerlink" title="import和模块"></a><code>import</code>和模块</h3><p>在R中，作者可以将他们的代码捆绑到可共享的扩展中，称为R包，R用户可以通过<code>library()</code>或<code>::</code>从R包中访问对象。在Python中，作者将代码捆绑到<strong>模块</strong>中，用户使用<code>import</code>访问模块。考虑这行代码：</p>
<p>这行语句让Python去文件系统，找到一个名为‘numpy’的已安装Python模块，加载它（通常意味着：评估它的<code>__init__.py</code>文件并构建一个<code>module</code>类型），并将其绑定到符号<code>numpy</code>。</p>
<p>在R中，这最接近于：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dplyr <span class="operator">&lt;-</span> loadNamespace<span class="punctuation">(</span><span class="string">&quot;dplyr&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h4 id="模块在哪里找到？"><a href="#模块在哪里找到？" class="headerlink" title="模块在哪里找到？"></a>模块在哪里找到？</h4><p>在Python中，模块被搜索的文件系统位置可以从<code>sys.path</code>列表中访问（和修改）。这是Python的<code>.libPaths()</code>的等价物。<br><code>sys.path</code>通常包含当前工作目录、包含内置标准库的Python安装、管理员安装的模块、用户安装的模块、来自环境变量如<code>PYTHONPATH</code>的值，以及其他代码在当前Python会话中直接对<code>sys.path</code>所做的任何修改（尽管这在实践中相对不常见）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br><span class="line"><span class="comment">#&gt; [&#x27;&#x27;, &#x27;/Users/tomasz/.pyenv/versions/3.12.4/bin&#x27;, &#x27;/Users/tomasz/.pyenv/versions/3.12.4/lib/python312.zip&#x27;, &#x27;/Users/tomasz/.pyenv/versions/3.12.4/lib/python3.12&#x27;, &#x27;/Users/tomasz/.pyenv/versions/3.12.4/lib/python3.12/lib-dynload&#x27;, &#x27;/Users/tomasz/.virtualenvs/r-reticulate/lib/python3.12/site-packages&#x27;, &#x27;/Users/tomasz/github/rstudio/reticulate/inst/python&#x27;, &#x27;/Users/tomasz/.virtualenvs/r-reticulate/lib/python312.zip&#x27;, &#x27;/Users/tomasz/.virtualenvs/r-reticulate/lib/python3.12&#x27;, &#x27;/Users/tomasz/.virtualenvs/r-reticulate/lib/python3.12/lib-dynload&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>你可以通过访问dunder <code>__path__</code>或<code>__file__</code>来检查模块被加载的位置（在解决安装问题时特别有用）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.__file__</span><br><span class="line"><span class="comment">#&gt; &#x27;/Users/tomasz/.virtualenvs/r-reticulate/lib/python3.12/os.py&#x27;</span></span><br><span class="line">numpy.__path__</span><br><span class="line"><span class="comment">#&gt; [&#x27;/Users/tomasz/.virtualenvs/r-reticulate/lib/python3.12/site-packages/numpy&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>一旦加载了模块，你就可以使用<code>.</code>来访问模块中的符号（等同于<code>::</code>，或者可能是R中的<code>$.environment</code>）。</p>
<p>还有特殊的语法来指定导入时模块绑定到的符号，以及导入特定符号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy        <span class="comment"># 导入</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  <span class="comment"># 导入并绑定到自定义符号`np`</span></span><br><span class="line">np <span class="keyword">is</span> numpy         <span class="comment"># 测试相同性，类似于identical(np, numpy)</span></span><br><span class="line"><span class="comment">#&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> <span class="built_in">abs</span> <span class="comment"># 只导入`numpy.abs`，绑定到`abs`</span></span><br><span class="line"><span class="built_in">abs</span> <span class="keyword">is</span> numpy.<span class="built_in">abs</span></span><br><span class="line"><span class="comment">#&gt; True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> <span class="built_in">abs</span> <span class="keyword">as</span> abs2 <span class="comment"># 只导入`numpy.abs`，绑定到`abs2`</span></span><br><span class="line">abs2 <span class="keyword">is</span> numpy.<span class="built_in">abs</span></span><br><span class="line"><span class="comment">#&gt; True</span></span><br></pre></td></tr></table></figure>

<p>如果你在寻找R的<code>library()</code>的Python等价物，它使包的所有导出符号可用，可能是使用<code>import</code>和<code>*</code></p>
<p>通配符，尽管这样做相对不常见。<code>*</code>通配符将扩展以包括模块中的所有符号，或者如果定义了<code>__all__</code>，则包括<code>__all__</code>中列出的所有符号。</p>
<p>Python不像R那样区分包导出和内部符号。在Python中，所有模块符号都是平等的，尽管有命名约定，即打算为内部使用的符号都带有单个前导下划线。（两个前导下划线调用高级语言功能称为“名称修饰”，这超出了本介绍的范围）。</p>
<h3 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h3><p>R用户通常不需要知道整数和浮点数之间的区别，但Python不是这种情况。<br>如果这是你第一次接触数值数据类型，以下是基础知识：</p>
<ul>
<li><p>整数类型只能表示像<code>1</code>或<code>2</code>这样的整数，不能表示像<code>1.2</code>这样的浮点数。</p>
</li>
<li><p>浮点类型可以表示任何数字，但有一定的精度损失。</p>
</li>
</ul>
<p>在R中，像<code>12</code>这样的裸字面量数字会产生浮点类型，而在Python中，它会产生整数。你可以在R中通过添加<code>L</code>后缀来产生整数字面量，如<code>12L</code>。许多Python函数期望整数，并在提供浮点数时会出错。</p>
<p>例如，假设我们有一个期望整数的Python函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_strict_Python_function</span>(<span class="params">x</span>):</span><br><span class="line">  <span class="keyword">assert</span> <span class="built_in">isinstance</span>(x, <span class="built_in">int</span>), <span class="string">&quot;x is not an int&quot;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Yay! x was an int&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>从R调用它时，你必须确保用整数调用它：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>reticulate<span class="punctuation">)</span></span><br><span class="line">py<span class="operator">$</span>a_strict_Python_function<span class="punctuation">(</span><span class="number">3</span><span class="punctuation">)</span>             <span class="comment"># 错误</span></span><br><span class="line"><span class="comment">#&gt; x is not an int</span></span><br><span class="line">py<span class="operator">$</span>a_strict_Python_function<span class="punctuation">(</span><span class="number">3L</span><span class="punctuation">)</span>            <span class="comment"># 成功</span></span><br><span class="line"><span class="comment">#&gt; Yay! x was an int</span></span><br><span class="line">py<span class="operator">$</span>a_strict_Python_function<span class="punctuation">(</span><span class="built_in">as.integer</span><span class="punctuation">(</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># 成功</span></span><br><span class="line"><span class="comment">#&gt; Yay! x was an int</span></span><br></pre></td></tr></table></figure>

<h3 id="R向量怎么样？"><a href="#R向量怎么样？" class="headerlink" title="R向量怎么样？"></a>R向量怎么样？</h3><p>R是一种首先为数值计算而设计的语言。数值向量数据类型深深植根于R语言中，以至于语言甚至不区分标量和向量。相比之下，Python中的数值计算能力通常由第三方包（Python术语中的<strong>模块</strong>）提供。</p>
<p>在Python中，<code>numpy</code>模块最常用于处理数据的连续数组。最接近R数值向量的等价物是numpy数组，有时是标量数字列表（一些Python用户可能会在这里支持<code>array.array()</code>，但在实际Python代码中很少遇到，我们不再进一步提及）。</p>
<p>教授NumPy接口超出了本初级指南的范围，但值得指出一些对习惯于R数组的用户可能遇到的陷阱：</p>
<ul>
<li>当索引到多维numpy数组时，可以省略尾随维度，并隐式地视为缺失。结果是，迭代数组意味着迭代第一个维度。例如，这会迭代矩阵的行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">m = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">m</span><br><span class="line"><span class="comment">#&gt; array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="comment">#&gt;        [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="comment">#&gt;        [ 8,  9, 10, 11]])</span></span><br><span class="line">m[<span class="number">0</span>, :] <span class="comment"># 第一行</span></span><br><span class="line"><span class="comment">#&gt; array([0, 1, 2, 3])</span></span><br><span class="line">m[<span class="number">0</span>]    <span class="comment"># 也是第一行</span></span><br><span class="line"><span class="comment">#&gt; array([0, 1, 2, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> m:</span><br><span class="line">  <span class="built_in">print</span>(row)</span><br><span class="line"><span class="comment">#&gt; [0 1 2 3]</span></span><br><span class="line"><span class="comment">#&gt; [4 5 6 7]</span></span><br><span class="line"><span class="comment">#&gt; [ 8  9 10 11]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>许多numpy操作会就地修改数组！这可能会让习惯于R的复制修改语义的R用户感到惊讶。不幸的是，没有简单的方案或命名约定可以依靠，以快速确定特定方法是否就地修改或创建新数组副本。唯一可靠的方法是查阅文档，并在<code>reticulate::repl_python()</code>中进行小实验。</li>
</ul>
<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>装饰器只是接受函数作为参数的函数，然后通常返回另一个函数。任何函数都可以被调用为装饰器，使用<code>@</code>语法，这只是糖，用于这个简单的动作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">  func.x = <span class="string">&quot;a decorator modified this function by adding an attribute `x`&quot;</span></span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(): <span class="keyword">pass</span></span><br><span class="line">my_function = my_decorator(my_function)</span><br><span class="line"></span><br><span class="line"><span class="comment"># @只是上述两行的花哨语法</span></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(): <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>你可能会经常遇到的一个装饰器是：</p>
<ul>
<li><code>@property</code>，当访问属性时自动调用类方法（类似于R中的<code>makeActiveBinding()</code>）。</li>
</ul>
<h3 id="with和上下文管理"><a href="#with和上下文管理" class="headerlink" title="with和上下文管理"></a><code>with</code>和上下文管理</h3><p>任何定义了<code>__enter__</code>和<code>__exit__</code>方法的对象都实现了“上下文”协议，并且可以传递给<code>with</code>。例如，这是一个自定义的上下文管理器实现，暂时更改当前工作目录（类似于R的<code>withr::with_dir()</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getcwd, chdir</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">wd_context</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, wd</span>):</span><br><span class="line">    <span class="variable language_">self</span>.new_wd = wd</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.original_wd = getcwd()</span><br><span class="line">    chdir(<span class="variable language_">self</span>.new_wd)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, *args</span>):</span><br><span class="line">    <span class="comment"># __exit__接受一些通常被忽略的额外参数</span></span><br><span class="line">    chdir(<span class="variable language_">self</span>.original_wd)</span><br><span class="line"></span><br><span class="line">getcwd()</span><br><span class="line"><span class="comment">#&gt; &#x27;/Users/tomasz/github/rstudio/reticulate/vignettes&#x27;</span></span><br><span class="line"><span class="keyword">with</span> wd_context(<span class="string">&quot;..&quot;</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;in the context, wd is:&quot;</span>, getcwd())</span><br><span class="line"><span class="comment">#&gt; in the context, wd is: /Users/tomasz/github/rstudio/reticulate</span></span><br><span class="line">getcwd()</span><br><span class="line"><span class="comment">#&gt; &#x27;/Users/tomasz/github/rstudio/reticulate/vignettes&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><p>希望这个简短的Python入门指南为你提供了一个良好的基础，让你有信心阅读Python文档和代码，并通过reticulate从R中使用Python模块。当然，还有更多关于Python的知识需要学习。在Google上搜索Python问题通常会得到大量的结果，但并不总是按照最有用排序。针对初学者的博客文章和教程可能很有价值，但请记住，Python的官方文档通常非常好，当你有问题时，它应该是你的第一个目的地。</p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/">https://docs.python.org/3/</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/index.html">https://docs.python.org/3/library/index.html</a></p>
<p>要更全面地学习Python，内置的官方教程也非常好和全面（但这需要时间承诺才能从中获得价值）<a target="_blank" rel="noopener" href="https://docs.python.org/3/tutorial/index.html">https://docs.python.org/3/tutorial/index.html</a></p>
<p>最后，不要忘记通过在<code>reticulate::repl_python()</code>中进行小实验来巩固你的理解。</p>
<p>感谢阅读！</p>
</div><div class="tags"><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul></div><div class="post-nav"><a class="pre" href="/2024/03/18/Github%20Copilot+ChatGPT-Next-Web%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/">Github Copilot+ChatGPT-Next-Web搭建记录</a><a class="next" href="/2023/10/14/%E6%97%A5%E8%AE%B0-2%EF%BC%9A7%E6%9C%88/">日记-2：7月</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://hechang22.github.io"/></form></div><div class="widget"><div class="author-info"><a class="info-avatar" href="/about/" title="About"><img class="nofancybox" src="/img/ava.png"/></a><p>一只鼠。</p><a class="info-icon" href="mailto:he-c22@mails.tsinghua.edu.cn" title="Email" target="_blank" style="margin-inline:5px"> <i class="fa fa-envelope-square" style="margin-inline:5px"></i></a><a class="info-icon" href="https://github.com/hechang22" title="Github" target="_blank" style="margin-inline:5px"> <i class="fa fa-github-square" style="margin-inline:5px"></i></a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E8%AE%B0/">日记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E4%BF%A1/">生信</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/">计算机</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/GPT/" style="font-size: 15px;">GPT</a> <a href="/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/tags/%E4%BD%9C%E4%B8%9A/" style="font-size: 15px;">作业</a> <a href="/tags/%E7%94%9F%E4%BF%A1/" style="font-size: 15px;">生信</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">笔记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2024/09/14/Practice-of-Bioinfomatic-note-1/">Practice of Bioinfomatic HW1</a></li><li class="post-list-item"><a class="post-list-link" href="/2024/03/18/Github%20Copilot+ChatGPT-Next-Web%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/">Github Copilot+ChatGPT-Next-Web搭建记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/22/Elementary-python-for-R-user/">给R用户的基础Python教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/10/14/%E6%97%A5%E8%AE%B0-2%EF%BC%9A7%E6%9C%88/">日记-2：7月</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/09/14/%E6%97%A5%E8%AE%B0-3%EF%BC%9A9%E6%9C%88/">日记-3：9月</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/31/%E3%80%8A%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%EF%BC%9A%E5%AF%BC%E8%AE%BA%E4%B8%8E%E6%96%B9%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0/">《生物信息学：导论与方法》笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/29/markdown%E8%AF%AD%E6%B3%95&%E4%B8%80%E4%BA%9Bmemo/">markdown语法&一些memo</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/06/01/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E2%80%94%E6%8C%87%E9%92%88/">程序设计基础复习—指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/29/%E6%97%A5%E8%AE%B0-1%EF%BC%9A6%E6%9C%88/">日记-1：6月</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2024 <a href="/." rel="nofollow">A tiny home.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="https://unpkg.com/@fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js?v=1.0.0" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>